{"name":"Angular-errorlookup","tagline":"Because AngularJS general error messages still suck. ngMessages can kiss my ass.","body":"[![Build Status](https://travis-ci.org/pocesar/angular-errorlookup.svg?branch=master)](https://travis-ci.org/pocesar/angular-errorlookup?branch=master) [![Coverage Status](https://coveralls.io/repos/pocesar/angular-errorlookup/badge.svg?branch=master&service=github)](https://coveralls.io/github/pocesar/angular-errorlookup?branch=master)\r\n\r\nAngularJS ErrorLookup\r\n===================\r\n\r\nBecause AngularJS general error messages still suck. ngMessages can kiss my ass.\r\n\r\nTL;DR http://pocesar.github.io/angular-errorlookup\r\n\r\nMade for Angular 1.4+, made in sexy Typescript\r\n\r\n## Install\r\n\r\n```bash\r\n$ bower install angular-errorlookup\r\n```\r\n\r\nHas jQuery and lodash as dependencies\r\n\r\n## Motivation\r\n\r\nHow is it better than `ngMessage` / `ngMessages`? Or plain old `ng-switch-when` / `ng-if` directive and a bunch of divs?\r\n\r\nBecause you need to write the same boring HTML markup over and over, and you need to cluttering your scope and\r\ncontrollers with useless state error messages. Plus, you are usually stuck with `modelController.$error` /\r\n`myForm.myModel.$error.required` / `myForm.$error.required[0].$error` (srsly wtf) boolean states.\r\n\r\nIt's nearly impossible to `$setValidity` without a helper directive that has access to some sort of global state,\r\nsince the ngModel controllers and form controllers are only available inside directives that require them or tied\r\nto a controller / scope. It's even worse, when you have to return validation from the server after a socket/ajax\r\ncall and show it in your form / models, or after async validation.\r\n\r\nSo, are you tired of no way of assigning errors dynamically, bypassing them when necessary? Does your scope variables\r\nlook like a mess with state errors? How about show a simple plain string on a form or console without assigning it\r\nto a scope/controller variable?\r\n\r\nTake this _superb_ code for example:\r\n\r\n```html\r\n<form name=\"userForm\">\r\n  <div class=\"field\">\r\n    <label for=\"emailAddress\">Enter your email address:</label>\r\n\r\n    <input type=\"email\"\r\n           name=\"emailAddress\"\r\n           ng-model=\"data.email\"\r\n           ng-minlength=\"5\"\r\n           ng-maxlength=\"30\"\r\n           required />\r\n\r\n    <div ng-messages=\"userForm.emailAddress.$error\">\r\n      <div ng-message=\"required\">You left the field blank...</div>\r\n      <div ng-message=\"minlength\">Your field is too short</div>\r\n      <div ng-message=\"maxlength\">Your field is too long</div>\r\n      <div ng-message=\"email\">Your field has an invalid email address</div>\r\n    </div>\r\n  </div>\r\n</form>\r\n```\r\n\r\nNow multiply that for 20 fields! Awesome right?\r\n\r\n![NO NO NO NO! HELL NO!](https://i.imgur.com/9utgk.gif)\r\n\r\nThis doesn't tie you with a controller or directives, and it doesn't aim to provide you a validation\r\ninterface. (Use [angular-async-validator](https://github.com/pocesar/angular-async-validator) for that)\r\n\r\n**This module aims to provide a D.R.Y. service for your errors, watching your models for ERRORS only**\r\n\r\nIt's an application-wide error messages service with helper directives for the heavy lifting! ngMessages\r\ndoesn't offer you a way to programatically set errors (unless you create a directive that requires ngModel\r\nand ngMessages, and you do the bridge, aka, hot mess).\r\n\r\nYou can use ErrorLookup in your DOM in a declarative manner, in your controller(s), in your directive(s),\r\nin  services (biggest win!), it keeps all your error messages under complete control (along with access\r\nto the bound element, scope and attributes), and you can have them using translations as well.\r\n\r\nBest of all: interpolation and callbacks! Make your errors beautiful and meaningful with magic. No more\r\nuseless boring generic messages like \"Please fill this field\" for every 350 fields in your forms and\r\ncopy pasting divs all over the place or making a damn directive that adds them after each of your\r\ninputs, and the need to use `$compile`, and all of the haX, like appending divs to DOM without you\r\nwanting it to.\r\n\r\n## Usage\r\n\r\n### Provider and Service\r\n\r\nThe `ErrorLookup` provider and service is that holds all messages and instances, models and attributes from your elements so it can be the ultimate overlord of your errors (and messages, but mostly errors, since it checks the `$error` member of the `ngModelController` and `FormController`).\r\n\r\n```js\r\nangular\r\n.module('YourApp', ['ngErrorLookup'])\r\n.config(['ErrorLookupProvider', function(ErrorLookupProvider){\r\n\r\n  // ErrorLookupProvider allows you to remove/add/overwrite your messages before your controllers load\r\n  ErrorLookupProvider.add('creditcard', 'The provided credit card isn\\'t valid');\r\n\r\n  ErrorLookupProvider.add('cvv', 'The CVV {{ model.$viewValue }} isn\\'t valid for {{ scope.cardType }}');\r\n\r\n  ErrorLookupProvider.add('repeated', 'The value {{ value }} doesn\\'t match {{ models.fucker.model.$viewValue }}');\r\n\r\n}])\r\n.controller('MainCtrl',\r\n  ['$scope', 'ErrorLookup',\r\n  function($scope, ErrorLookup){\r\n\r\n    // ErrorLookup is the full blown service\r\n    ErrorLookup.messages.types.email({value: 'name'}); // name is not a valid email\r\n\r\n    // Everything in types are a function from \"$interpolate\"\r\n    // You can overwrite them by using:\r\n    ErrorLookup.messages.add('email', 'O email \"{{value}}\" não é válido');\r\n    ErrorLookup.messages.types.email({value: 'name'}); // O email \"name\" não é válido\r\n  }\r\n]);\r\n```\r\n\r\nEasily retrieve localized messages from the server:\r\n\r\n```js\r\nangular\r\n.module('YourApp', ['ngErrorLookup'])\r\n// just use the helper FFS\r\n// assuming your json structure is:\r\n\r\n/*\r\n  {\r\n     \"required\": \"Você precisa preencher este campo\",\r\n     \"email\": \"O email \\\"{{ value }}\\\" é inválido\",\r\n     \"blacklist\": \"O <strong>email</strong> não é permitido\"\r\n  }\r\n */\r\n.run(['ErrorLookup', function(ErrorLookup){\r\n  // Load ALL the messages\r\n  ErrorLookup.messages.include('/error-messages.json').then(function(messages){\r\n    // changing messages change them internally before applying it\r\n    delete messages['required'];\r\n  });\r\n}]);\r\n```\r\n\r\n### Locals for usage in message strings\r\n\r\nBut that's only for adding and manually setting error messages, which isn't much different from\r\nadding stuff to your controllers. We want moar.\r\n\r\nThere are a couple of locals you can use in your string messages:\r\n\r\n##### `{{ $label }}`\r\n\r\nPretty name of the model, instead of displaying \"login.data.user.email\" to the user, display\r\n something like \"Your email\". On the directive, it's the value of `error-lookup-label`\r\n\r\n##### `{{ $model }}`\r\n\r\nThe ngModel itself with all the bells and whistles, unchanged. On the directive, it's the\r\nvalue of `ng-model`\r\n\r\n##### `{{ $form }}`\r\n\r\nThis will only be available if it's triggered using `error-lookup-form`.\r\n\r\n##### `{{ $name }}`\r\n\r\nThe $name is the assigned name using `error-lookup-name`, `name` or `ng-model` attributes.\r\n\r\n##### `{{ $attrs }}`\r\n\r\nThe $attrs from the current element with all the bells and whistles, unchanged\r\nYou can even add CSS classes to the element through here, omg messy spaghetti!\r\n\r\n##### `{{ $value }}`\r\n\r\nAlias for the current model `$viewValue`. If you want the `$modelValue` use `$model.$modelValue`.\r\n\r\n##### `{{ $scope }}`\r\n\r\nThe assigned scope. You may access your controller doing `$scope.yourcontroller` in here as well.\r\n\r\n##### `{{ $models }}`\r\n\r\nALL the models in the current group! Means you can reference other `ngModels`, how cool is that?\r\n\r\nSince it uses interpolation, you always need to run the curryed function returned\r\nfrom the `ErrorLookup.error()`, since it has no watches and doesn't use `$compile` (that\r\nwatch over expressions automatically):\r\n\r\n```js\r\nangular\r\n.module('YourApp', ['ngErrorLookup'])\r\n.controller('MainCtrl',\r\n  ['$scope', 'ErrorLookup',\r\n  function($scope, ErrorLookup) {\r\n\r\n    $scope.error = ErrorLookup.error('MainCtrl', 'user.email');\r\n    // this function changes the internal error array of the current model everytime it's called, plus it returns\r\n    // the current error collection! (that is, an array of objects) So it's a setter AND a getter\r\n    // <div ng-repeat=\"error in error() track by error.message\"></div>\r\n\r\n    // Get ALL the errors in a group and assign them to the scope\r\n    $scope.errors = ErrorLookup.errors('MainCtrl');\r\n    // $scope.errors.user\r\n    // $scope.errors.password\r\n    // $scope.errors.repeat\r\n    // $scope.errors.fullname\r\n    // $scope.errors.email\r\n    // <div ng-repeat=\"error in errors.user() track by error.message\"></div>\r\n\r\n    // plucking just a few members\r\n    $scope.errors = ErrorLookup.errors('MainCtrl', ['user','password']);\r\n    // $scope.errors.user()\r\n    // $scope.errors.password()\r\n\r\n    // or the controller-bound preferred way\r\n    this.error = ErrorLookup.error('group', 'full.qualified.modelname.as.written.in.ng-model');\r\n  }\r\n]);\r\n```\r\n\r\n`ErrorLookup.error(group, modelIdentifier, predefine)` return a function that has the following signature `function(extra)`.\r\nEffectively, you can trigger new errors without the error being present on the model, like when you return validation from the server, without using `model.$setValidity`.\r\n\r\n```js\r\n$http.post('/isValid', {type: 'email', email: $scope.email}).success(function(errors){\r\n  if (errors !== false) {\r\n    $scope.error(errors); // assuming errors = {'blacklist': true, 'required': true}\r\n    // will look for default blacklist and required messages\r\n\r\n    // if you assign an string, it will be shown instead of the predefined messages\r\n    $scope.error({\r\n      'blacklist': 'You failed to enter your email, {{ $value }} even make sense to you? You dirty spammer'\r\n    }); // $interpolates this on the fly, not healthy for performance, beware\r\n  }\r\n});\r\n```\r\n\r\nBut wait! You don't need to add an string that will be interpolated, you can use a function! ...Here be dragons...\r\n\r\n```js\r\nErrorLookup.messages.add('dynamic', function(model){\r\n  // model is the programmatically equivalent of the scope variables in your interpolated string above\r\n  // \"this\" context is the internal \"model\"\r\n  if (model.$group === 'login') {\r\n      return 'Login failed';\r\n  } else if (model.$group === 'another') {\r\n      return 'Some shit happened';\r\n  }\r\n  // You must return an string here. Interpolate if you want, ErrorLookup don't care\r\n  return 'You failed';\r\n});\r\n```\r\n\r\nSo let the clusterfuck ensue! Break ALL the conventions! Access ALL the models! Pass ALL elements to callbacks! Wreck ALL the declarative behavior!\r\n\r\n## API\r\n\r\n### Provider\r\n\r\n##### `ErrorLookupProvider.add(name: String, expr: String|Function, trustedContext:String)`\r\n\r\nQueue a message to be lazy initialized when the ErrorLookup service is instantiated for the first time.\r\n\r\n```js\r\nErrorLookupProvider.add('required','<strong>{{ label }}</strong> is awesome, you gotta fill it', 'html');\r\nErrorLookupProvider.add('hallelujah','praise almighty code');\r\n```\r\n\r\n##### `ErrorLookupProvider.remove(name: String)`\r\n\r\nRemove a message from the queue.\r\n\r\n```js\r\nErrorLookupProvider.remove('required');\r\n```\r\n\r\n### Service\r\n\r\n\r\n#### ErrorLookup.translate(message: string): Function;\r\n\r\nReturns the interpolated function, shortcut for `this.messages[message]`.\r\nThrows if not defined\r\n\r\n```js\r\nErrorLookup.translate('notrequired'); // throws\r\n```\r\n\r\n#### ErrorLookup.validity(group: string, name: string, defs: {}): QPromise<Errors[]>;\r\n\r\nCalls `$setValidity` in the underlaying ngModel manually. Does nothing for forms.\r\n\r\n```js\r\nErrorLookup.validity('group','name', {\r\n    required: false,\r\n    email: true\r\n}).then(function(errors){\r\n    // errors = array\r\n});\r\n```\r\n\r\n#### ErrorLookup.validate(group: string, name: string): QPromise<Errors[]>;\r\n\r\nCalls `$validate` in the underlaying ngModel manually. If it's a form, it calls `$validate()` in all\r\nthe children.\r\n\r\n```js\r\nErrorLookup.validate('group','name');\r\n// calls ngModel.$validate();\r\n```\r\n\r\n#### ErrorLookup.errors(group: string, pick?: string[], errorArrays: boolean = false, predefine: {}, helpers: boolean = true, reset: boolean = true): {};\r\n\r\nBread and butter, returns an object with all the error messages helpers for a group, or you can pick some manually\r\n\r\n#### ErrorLookup.reset(group: string, name: string, pick: string[]): QPromise<Errors[]>;\r\n\r\nReset forced errors set using `ErrorLookup.set()` function\r\n\r\n#### ErrorLookup.set(group: string, name: string, errors: {}, reset: boolean = true): QPromise<Errors[]>;\r\n\r\nSet programatically an error and return a promise with the updated errors array.\r\nResets the errors if you specify, sets the model to dirty, and the form to dirty, then forcefully set the errors without updating the `ngModel.$errors`.\r\nIt's a sticky but superficial error, that isn't attached to the ngModel itself.\r\nUsually good to show error forms that come from the server, or manually set errors on inputs without actually making them invalid.\r\n\r\n```js\r\nErrorLookup.set('group','name', {\r\n    registered: true, // use the default registered error\r\n    domain: 'Domain is invalid' // override the default message\r\n}, true);\r\n```\r\n\r\n#### ErrorLookup.get(group: string, name: string = '', helpers = false, predefined: boolean = false): IErrorHelper;\r\n\r\nReturn either the whole group, a model, or helpers to save some calls to `ErrorLookup.item`,\r\n`ErrorLookup.error`, `ErrorLookup.set`, `ErrorLookup.label`, etc\r\n\r\n```js\r\nvar group = ErrorLookup.get('group', 'helper', true);\r\n/*\r\nreturns\r\n{\r\n    item: groupHelperModel,\r\n    error: Function,\r\n    set: (error: any),\r\n    label: (item: string, name: string),\r\n    reset: (pick: string[]),\r\n    validity: (validity: any  = {}),\r\n    remove: ()\r\n}\r\n*/\r\n```\r\n\r\n##### ErrorLookup.label(group: string, name: string|{}, label: string = ''): this;\r\n\r\nSet a pretty name for a model, can set many labels at once if you pass an object to the name.\r\n\r\n```typescript\r\nErrorLookup.label('somegroup', 'login.data.name', 'Login user');\r\nErrorLookup.label('somegroup', {\r\n    'login.data.name': 'Login user',\r\n    'login.data.pass': 'Password'\r\n});\r\n```\r\n\r\n##### `ErrorLookup.error(group: String, name: String, predefine: Object)`\r\n\r\nReturns a function so you can control the error for that field. Executing the returning function\r\nreturns an array with the errors (or an empty array if none). The errors are kept internally between\r\ncalls per model.\r\n\r\n```js\r\n// fn is Function(Extra: Object|Boolean): Array\r\nvar fn = ErrorLookup.error('group','user');\r\nfn({'required':true});\r\n/* returns */\r\n[\r\n  {\r\n    type:'required',\r\n    message:'You must fill user',\r\n    label:'user',\r\n    name:'user',\r\n    item:Model\r\n  }\r\n]\r\n```\r\n\r\nYou can also bypass the current messages that are set for a particular model, making it unique for the same error type\r\n\r\n```js\r\n// fn is Function(Extra: Object|Boolean): Array\r\nvar fn = ErrorLookup.error('group','user',{'required':'User is sooo required, please fill me in'});\r\nfn({'required':true});\r\n/* returns */\r\n[\r\n  {\r\n    type:'required',\r\n    message:'User is sooo required, please fill me in',\r\n    label:'user',\r\n    name:'user',\r\n    item:Model\r\n  }\r\n]\r\n```\r\n\r\nAnd you can bypass the bypass!\r\n\r\n```js\r\n// fn is Function(Extra: Object|Boolean): Array\r\nvar fn = ErrorLookup.error('group','user',{'required':'User is sooo required, please fill me in'});\r\nfn({'required':'w00t'});\r\n/* returns */\r\n[\r\n  {\r\n    type:'required',\r\n    message:'w00t',\r\n    label:'user',\r\n    name:'user',\r\n    item:Model\r\n  }\r\n]\r\n```\r\n\r\n##### `ErrorLookup.errors(group: String, pick: string[], arrays: Boolean = false, predefine: Object = {})`\r\n\r\nReturns an object with all the error functions from above. If you define an array in pick, you can retrieve\r\nonly some members of the group.\r\n\r\n```js\r\nvar errors = ErrorLookup.errors('group',['user','email']); // returns {'user':ErrorGetterFunction,'email':ErrorGetterFunction}\r\nerrors.user(); // [{type:'required'...}]\r\n```\r\n\r\nsetting arrays to true returns the current errors array:\r\n\r\n```js\r\nvar errors = ErrorLookup.errors('group', ['user','email'], true); // returns {'user':Array,'email':Array}\r\nerrors.user; // [{type:'required'...}]\r\n// the ErrorLookup.error() must be called somewhere for this array to be filled\r\n```\r\n\r\nYou can override the default errors of a group:\r\n\r\n```js\r\nvar errors = ErrorLookup.errors('group', [], false, {'required':'w00b'}); // returns {'user':ErrorFunction,'email':ErrorFunction,'password':ErrorFunction}\r\nerrors.email({required: true}); // [{type:'required','message':'w00b'}]\r\nerrors.password({required: true}); // [{type:'required','message':'w00b'}]\r\n```\r\n\r\n##### `ErrorLookup.remove(group: String, name: String)`\r\n\r\nRemove the model from the errors pile\r\n\r\n```js\r\nErrorLookup.remove(scope.$id, 'user');\r\nErrorLookup.remove('whole group'); // warning, remove the entire group\r\n```\r\n\r\n##### `ErrorLookup.add(config: Object)`\r\n\r\nThis method is boring as hell. Long parameter list and you shouldn't need to call it manually if you use the\r\ndirectives. You need to always provide non-optional stuff everytime to the function or it breaks.\r\n\r\nThe config object is as following:\r\n\r\n* `config.scope`      : the current scope. [Not Optional]\r\n* `config.name`       : the name of the ng-model, or any internal name you want to use. it must exist in the given scope [Not Optional]\r\n* `config.el`         : assign a DOM element to the current model [Not optional]\r\n* `config.group`      : the group name [Not optional]\r\n* `config.controller` : the model itself ngModelController (or ngFormController if you add a form model to it) [Not Optional]\r\n* `config.isForm`     : is the current controller FormController?\r\n* `config.attrs`      : the $attrs of the element, you can pass an object too when not adding from inside a directive\r\n* `config.label`      : the label to give the error. Defaults to the name of the model. pretty name for your `login.data.user` as `Your username` for example\r\n* `config.parent`     : set another ErrorLookup model as parent (not controllers!)\r\n\r\n```js\r\n/* ... */\r\n.directive('blah', ['ErrorLookup', function(ErrorLookup){\r\n  return {\r\n    require:'ngModel',\r\n    link: function($scope, el, attr, ctrl){\r\n\r\n      ErrorLookup.add({\r\n        scope      : $scope,\r\n        group      : $scope.$id,\r\n        name       : attr.ngModel,\r\n        controller : ctrl,\r\n        el         : el\r\n      });\r\n    }\r\n  }\r\n}]);\r\n```\r\n\r\n##### `ErrorLookup.messages`\r\n\r\nKeeps your application wide messages in a repository\r\n\r\n##### `ErrorLookup.messages.add(name: String, expr: String|Function, trustedContext: String)`\r\n\r\nAdds a message. Accepts a function (callback!) or a interpolated string. If you set `trustedContext` to 'html'\r\nit will use the `$sce` service and accept safe HTML in your interpolated string.\r\n\r\n```js\r\nErrorLookup.messages.add('required', '<span class=\"well\">You need to fill this field</span>', 'html');\r\n```\r\n\r\nReturns the current `$interpolate`d string or the function you passed, you can call it right way.\r\n\r\n##### `ErrorLookup.messages.remove(name: String)`\r\n\r\nRemove a message from the service\r\n\r\n```js\r\nErrorLookup.messages.remove('required'); // all \"required\" error messages, will be silently skipped when this error is present on ngModel =(\r\n```\r\n\r\n##### `ErrorLookup.messages.include(url: String)`\r\n\r\nLoads a JSON representation of your messages.\r\nReturns a promise. If you modify the resulting value, you can modify the included messages\r\n\r\n```js\r\nErrorLookup.messages.include('/messages.json').then(function(messages){\r\n  delete messages['required'];\r\n});\r\n```\r\n\r\n### Directives\r\n\r\n#### `error-lookup`\r\n\r\nThe `error-lookup` directive will add any `ng-model` element to the bunch.\r\n\r\nBy default, `error-lookup` group elements by `scope.$parent.$id`, but you can set your\r\nown name using `error-lookup=\"othergroup\"` (it's preferable this way, so you can reuse in\r\nyour code and set errors from inside services and other directives)\r\n\r\nThe name of the model will be your `error-lookup-name`, then `name` attribute, then your `ng-model`,\r\nin this order.\r\n\r\n`error-lookup-label` can apply a nice name to your model, like `error-lookup-label=\"Your email\"`.\r\n\r\n```html\r\n<!-- add this ngModel to our ErrorLookup service -->\r\n<input\r\n  ng-model=\"model.email\"\r\n  error-lookup-label=\"your email\"\r\n  error-lookup=\"login.interface\"\r\n  error-lookup-name=\"email\"\r\n  type=\"email\"\r\n  required\r\n  >\r\n\r\n<!-- error-lookup-label changes the $label variable -->\r\n<!-- error-lookup-name overrides your ng-model and name attributes -->\r\n\r\n<!-- You can, inside your controller, now use\r\n     ErrorLookup.get('login.interface','email'), and\r\n     even have access to this element lol, breaking\r\n     conventions since 2014\r\n     -->\r\n\r\n<!-- Display some nasty errors to the user, only from\r\n     login.interface and email model -->\r\n\r\n<ol error-lookup-display=\"email\" error-lookup-group=\"login.interface\">\r\n  <li>{{ $latest.message }}</li> <!-- only the latest error in the stack -->\r\n  <li>{{ $first.message }}</li> <!-- only the latest error in the stack -->\r\n  <li ng-bind-html=\"$firstHtml\"></li> <!-- only the latest error in the stack -->\r\n  <li ng-bind-html=\"$latestHtml\"></li> <!-- only the latest error in the stack -->\r\n  <li ng-repeat=\"error in $errors track by $index\">{{error.message}}</li> <!-- or show ALL the errors -->\r\n  <!-- you can even make your shit clickable -->\r\n  <li ng-repeat=\"error in $errors track by $index\" ng-click=\"myWorldController.click(error)\" ng-bind-html=\"error.message\"></li>\r\n  <li>Shit! {{ $errorCount }} errors!</li>\r\n</ol>\r\n```\r\n\r\n#### `error-lookup-form`\r\n\r\nThis one is for forms, they keep all their children in sync (long missing from angular itself).\r\n\r\n```html\r\n<!-- you can put it on forms, you can display errors for your form as a whole -->\r\n<form error-lookup-form=\"group\" name=\"fuck\">\r\n  <input ng-model=\"doh\" error-lookup=\"another-group\">\r\n  <input ng-model=\"srsly\" error-lookup=\"another-group\">\r\n  <input ng-model=\"input\" error-lookup=\"another-group\">\r\n  <div\r\n      error-lookup-group=\"group\"\r\n      error-lookup-display=\"fuck\"\r\n      error-lookup-template=\"{filter:['form','only','errors'],exclude:['required']}\"\r\n      ></div>\r\n  <!-- show all errors for all form models on one place -->\r\n</form>\r\n```\r\n\r\n#### `error-lookup-display`\r\n\r\nThe `error-lookup-display` is a shortcut to the `ErrorLookup.error()` function.\r\n\r\nThis directive exposes to the DOM the following scope variables:\r\n\r\n##### `$model: IErrorHelper;`\r\n\r\nThe ErrorLookup model\r\n\r\n##### `$errorCount: number;`\r\n\r\nCurrent error count\r\n\r\n##### `$first: IErrorMessage;`\r\n\r\nIs first error for that field, containing the fields described in\r\n[ErrorLookup.error()](#errorlookuperrorgroup-string-name-string-predefine-object)\r\n\r\n##### `$latest: IErrorMessage;`\r\n\r\nIs the top most error for that field, containing the fields described in\r\n[ErrorLookup.error()](#errorlookuperrorgroup-string-name-string-predefine-object)\r\n\r\n##### `$errors: any[];`\r\n\r\nCurrent cached array of errors\r\n\r\n##### `$hasChanged(): boolean;`\r\n\r\nIf the field has errors AND is `$dirty` AND has been `$touched`\r\n\r\nN.B: Since the scope isn't isolated, but a child scope, it inherits from the current scope it's in,\r\nmake sure to understand scope inheritance before you try your hax0rs in the code.\r\n\r\n##### `$latestHtml: angular.IAugmentedJQuery;`\r\n\r\nThe `$sce.trustAsHtml` version of `$latest`\r\n\r\n##### `$firstHtml: angular.IAugmentedJQuery;`\r\n\r\nThe `$sce.trustAsHtml` version of `$first`\r\n\r\n#### `error-lookup-template`\r\n\r\nThis directive creates a `ul` with a default limit of 1 item for errors.\r\nIt needs to be applied in the same element that has `error-lookup-display` on it.\r\n\r\n```html\r\n<div\r\n    error-lookup-display=\"models.email\"\r\n    error-lookup-template=\"{filter: ['generic','someothererror', $variable], 'exclude':['required'], limit: 10}\"\r\n    >\r\n  <!-- setting `filter` will only show `generic`, 'someothererror' and something assigned to the scope $variable,\r\n      error messages -->\r\n  <!-- setting `limit` will limit the number of messages displayed at once -->\r\n  <!-- setting `exclude` won't show errors -->\r\n  <!-- all options are optional, they default to none and 1 respectively -->\r\n</div>\r\n```\r\n\r\n### Filter\r\n\r\nIt's used to filter error messages from a bunch of items in an array,\r\nused by the `error-lookup-template` directive:\r\n\r\n```html\r\n<div error-lookup-display=\"name\">\r\n  <div ng-repeat=\"error in $errors | errorMessages:$options\">{{ error }}</div>\r\n</div>\r\n```\r\n","google":"UA-10569443-35","note":"Don't delete this file! It's used internally to help with page regeneration."}